<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STRATCOM - Command Center</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/menu.css">
</head>
<body>
    <div class="crt-overlay"></div>
    
    <!-- Header Bar -->
    <header class="menu-header">
        <div class="header-left">
            <span class="logo-icon">‚óâ</span>
            <span class="logo-text">STRATCOM</span>
        </div>
        <div class="header-center">
            <span class="header-title">STRATEGIC COMMAND CENTER</span>
        </div>
        <div class="header-right">
            <div class="user-info" id="user-info">
                <span class="user-rank">CMDR</span>
                <span class="user-name" id="user-name">OPERATOR</span>
                <button class="logout-btn" onclick="handleLogout()" title="Logout">‚èª</button>
            </div>
        </div>
    </header>

    <main class="menu-container">
        <!-- Left Panel - Menu Options (1/3) -->
        <aside class="menu-panel">
            <div class="panel-section">
                <h2 class="section-title">
                    <span class="title-icon">‚óÜ</span>
                    COMMAND OPTIONS
                </h2>
                
                <nav class="menu-nav">
                    <button class="menu-btn" id="btn-new-game" onclick="showModal('new-game-modal')">
                        <span class="btn-icon">‚äï</span>
                        <span class="btn-content">
                            <span class="btn-title">NEW CAMPAIGN</span>
                            <span class="btn-desc">Begin a new strategic operation</span>
                        </span>
                        <span class="btn-arrow">‚ñ∂</span>
                    </button>
                    
                    <button class="menu-btn" id="btn-load-game" onclick="showModal('load-game-modal')">
                        <span class="btn-icon">‚ä°</span>
                        <span class="btn-content">
                            <span class="btn-title">LOAD CAMPAIGN</span>
                            <span class="btn-desc">Resume saved operation</span>
                        </span>
                        <span class="btn-arrow">‚ñ∂</span>
                    </button>
                    
                    <button class="menu-btn" id="btn-multiplayer" onclick="showModal('multiplayer-modal')">
                        <span class="btn-icon">‚äõ</span>
                        <span class="btn-content">
                            <span class="btn-title">MULTIPLAYER</span>
                            <span class="btn-desc">Joint operations command</span>
                        </span>
                        <span class="btn-arrow">‚ñ∂</span>
                    </button>
                    
                    <button class="menu-btn" id="btn-settings" onclick="showModal('settings-modal')">
                        <span class="btn-icon">‚öô</span>
                        <span class="btn-content">
                            <span class="btn-title">SETTINGS</span>
                            <span class="btn-desc">System configuration</span>
                        </span>
                        <span class="btn-arrow">‚ñ∂</span>
                    </button>
                </nav>
            </div>

            <div class="panel-section">
                <h2 class="section-title">
                    <span class="title-icon">‚óÜ</span>
                    OPERATOR STATUS
                </h2>
                <div class="status-info">
                    <div class="status-row">
                        <span class="status-label">CLEARANCE</span>
                        <span class="status-value">TOP SECRET</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">CAMPAIGNS</span>
                        <span class="status-value" id="stat-campaigns">0</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">VICTORIES</span>
                        <span class="status-value" id="stat-wins">0</span>
                    </div>
                    <div class="status-row">
                        <span class="status-label">PLAYTIME</span>
                        <span class="status-value" id="stat-time">0h 0m</span>
                    </div>
                </div>
            </div>

            <div class="panel-section console-section">
                <h2 class="section-title">
                    <span class="title-icon">‚óÜ</span>
                    SYSTEM LOG
                </h2>
                <div class="console-output" id="console-output">
                    <!-- Console messages will appear here -->
                </div>
            </div>
        </aside>

        <!-- Right Panel - Globe Animation (2/3) -->
        <section class="globe-panel">
            <div class="globe-container" id="globe-container">
                <!-- Three.js globe will be rendered here -->
            </div>
            
            <!-- Radar sweep overlay -->
            <div class="radar-sweep"></div>
            
            <!-- Scanning tracker -->
            <div class="scan-overlay" id="scan-overlay">
                <div class="scan-tracker" id="scan-tracker">
                    <div class="scan-frame"></div>
                    <div class="scan-corner tl"></div>
                    <div class="scan-corner tr"></div>
                    <div class="scan-corner bl"></div>
                    <div class="scan-corner br"></div>
                    <div class="scan-crosshair"></div>
                    <div class="scan-info-panel" id="scan-info-panel">
                        <div class="scan-header">
                            <span class="scan-classification" id="scan-class">NEUTRAL</span>
                            <span class="scan-id" id="scan-id">TGT-0000</span>
                        </div>
                        <div class="scan-type" id="scan-type">UNKNOWN</div>
                        <div class="scan-details" id="scan-details"></div>
                        <div class="scan-status" id="scan-status">ANALYZING...</div>
                    </div>
                </div>
            </div>
            
            <!-- Info overlays -->
            <div class="globe-info top-left">
                <div class="info-label">SATELLITE COVERAGE</div>
                <div class="info-value" id="sat-coverage">98.7%</div>
            </div>
            
            <div class="globe-info top-right">
                <div class="info-label">ACTIVE THREATS</div>
                <div class="info-value warning" id="threat-count">0</div>
            </div>
            
            <div class="globe-info bottom-left">
                <div class="info-label">TRACKED OBJECTS</div>
                <div class="info-value" id="tracked-objects">2,847</div>
            </div>
            
            <div class="globe-info bottom-right">
                <div class="info-label">NETWORK STATUS</div>
                <div class="info-value success" id="network-status">NOMINAL</div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="menu-footer">
        <div class="footer-left">
            <span class="footer-status">
                <span class="status-dot online"></span>
                <span>CONNECTED TO STRATCOM NETWORK</span>
            </span>
        </div>
        <div class="footer-center">
            <span class="footer-version">v2.1.7 BUILD 20251215</span>
        </div>
        <div class="footer-right">
            <span class="footer-time" id="system-time">00:00:00 UTC</span>
        </div>
    </footer>

    <!-- ==================== MODALS ==================== -->
    
    <!-- New Game Modal -->
    <div class="modal-overlay" id="new-game-modal" onclick="closeModalOnOverlay(event)">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">NEW CAMPAIGN</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">OPERATION CODENAME</label>
                    <input type="text" id="game-name" class="form-input" placeholder="OPERATION THUNDERSTRIKE">
                </div>
                <div class="form-group">
                    <label class="form-label">STARTING NATION</label>
                    <select id="game-nation" class="form-input">
                        <option value="">-- SELECT NATION --</option>
                        <option value="USA">üá∫üá∏ United States of America</option>
                        <option value="CHN">üá®üá≥ People's Republic of China</option>
                        <option value="RUS">üá∑üá∫ Russian Federation</option>
                        <option value="DEU">üá©üá™ Germany</option>
                        <option value="GBR">üá¨üáß United Kingdom</option>
                        <option value="FRA">üá´üá∑ France</option>
                        <option value="JPN">üáØüáµ Japan</option>
                        <option value="IND">üáÆüá≥ India</option>
                        <option value="BRA">üáßüá∑ Brazil</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">DIFFICULTY</label>
                    <select id="game-difficulty" class="form-input">
                        <option value="recruit">RECRUIT - Tutorial guidance</option>
                        <option value="officer" selected>OFFICER - Standard challenge</option>
                        <option value="commander">COMMANDER - Enhanced AI</option>
                        <option value="general">GENERAL - Maximum realism</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn secondary" onclick="closeModal()">ABORT</button>
                <button class="modal-btn primary" onclick="startNewGame()">COMMENCE OPERATION</button>
            </div>
        </div>
    </div>

    <!-- Load Game Modal -->
    <div class="modal-overlay" id="load-game-modal" onclick="closeModalOnOverlay(event)">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">LOAD CAMPAIGN</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="saves-list" id="saves-list">
                    <div class="saves-loading">SCANNING ARCHIVES...</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn secondary" onclick="closeModal()">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Multiplayer Modal -->
    <div class="modal-overlay" id="multiplayer-modal" onclick="closeModalOnOverlay(event)">
        <div class="modal wide">
            <div class="modal-header">
                <h2 class="modal-title">MULTIPLAYER COMMAND</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="mp-tabs">
                    <button class="mp-tab active" onclick="switchMPTab('join')">JOIN GAME</button>
                    <button class="mp-tab" onclick="switchMPTab('host')">HOST GAME</button>
                </div>
                
                <div class="mp-content" id="mp-join">
                    <div class="form-group">
                        <label class="form-label">LOBBY CODE</label>
                        <input type="text" id="lobby-code" class="form-input" placeholder="ENTER 6-DIGIT CODE" maxlength="6" style="text-transform: uppercase;">
                    </div>
                    <button class="modal-btn primary" onclick="joinLobby()" style="width: 100%;">JOIN LOBBY</button>
                    
                    <div class="divider"><span>OR BROWSE LOBBIES</span></div>
                    
                    <div class="lobbies-list" id="lobbies-list">
                        <div class="saves-loading">SCANNING FOR ACTIVE LOBBIES...</div>
                    </div>
                </div>
                
                <div class="mp-content hidden" id="mp-host">
                    <div class="form-group">
                        <label class="form-label">LOBBY NAME</label>
                        <input type="text" id="host-name" class="form-input" placeholder="OPERATION MULTIPLAYER">
                    </div>
                    <div class="form-group">
                        <label class="form-label">MAX PLAYERS</label>
                        <select id="host-players" class="form-input">
                            <option value="2">2 Players</option>
                            <option value="4" selected>4 Players</option>
                            <option value="6">6 Players</option>
                            <option value="8">8 Players</option>
                        </select>
                    </div>
                    <button class="modal-btn primary" onclick="createLobby()" style="width: 100%;">CREATE LOBBY</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn secondary" onclick="closeModal()">CANCEL</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal" onclick="closeModalOnOverlay(event)">
        <div class="modal">
            <div class="modal-header">
                <h2 class="modal-title">SETTINGS</h2>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">GRAPHICS QUALITY</label>
                    <select id="setting-quality" class="form-input">
                        <option value="low">LOW</option>
                        <option value="medium" selected>MEDIUM</option>
                        <option value="high">HIGH</option>
                        <option value="ultra">ULTRA</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">SOUND VOLUME</label>
                    <input type="range" id="setting-volume" class="form-range" min="0" max="100" value="70">
                </div>
                <div class="form-group">
                    <label class="form-label">
                        <input type="checkbox" id="setting-scanlines" checked>
                        CRT SCANLINE EFFECT
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn secondary" onclick="closeModal()">CANCEL</button>
                <button class="modal-btn primary" onclick="saveSettings()">SAVE SETTINGS</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <!-- Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCwm6URBOZqa7RG2WyqjYpcB-fTt2TOu14",
            authDomain: "stratcom-global-cmd.firebaseapp.com",
            projectId: "stratcom-global-cmd",
            storageBucket: "stratcom-global-cmd.firebasestorage.app",
            messagingSenderId: "546213515536",
            appId: "1:546213515536:web:7178a4229352c2d68ed595"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        // Check auth state
        auth.onAuthStateChanged((user) => {
            if (!user) {
                window.location.href = 'login.html';
            } else {
                initializeMenu(user);
            }
        });

        // ==================== MENU INITIALIZATION ====================
        
        function initializeMenu(user) {
            // Update user info
            document.getElementById('user-name').textContent = 
                (user.displayName || user.email.split('@')[0]).toUpperCase();
            
            // Log to console
            logMessage('System initialized', 'success');
            logMessage(`Operator authenticated: ${user.email}`, 'info');
            logMessage('Globe renderer starting...', 'info');
            
            // Initialize globe
            initGlobe();
            
            // Start time update
            updateTime();
            setInterval(updateTime, 1000);
            
            // Load user stats
            loadUserStats(user.uid);
        }
        
        // Make functions globally available
        window.handleLogout = async function() {
            await auth.signOut();
            window.location.href = 'login.html';
        };
        
        window.showModal = function(modalId) {
            document.getElementById(modalId).classList.add('active');
            if (modalId === 'load-game-modal') loadSavedGames();
        };
        
        window.closeModal = function() {
            document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('active'));
        };
        
        window.closeModalOnOverlay = function(e) {
            if (e.target.classList.contains('modal-overlay')) closeModal();
        };
        
        window.switchMPTab = function(tab) {
            document.querySelectorAll('.mp-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.mp-content').forEach(c => c.classList.add('hidden'));
            event.target.classList.add('active');
            document.getElementById('mp-' + tab).classList.remove('hidden');
        };
        
        window.startNewGame = function() {
            const nation = document.getElementById('game-nation').value;
            if (!nation) {
                alert('Please select a nation');
                return;
            }
            
            const config = {
                name: document.getElementById('game-name').value || 'OPERATION ' + generateCodename(),
                nation: nation,
                difficulty: document.getElementById('game-difficulty').value
            };
            
            // Store config and redirect to game
            sessionStorage.setItem('newGameConfig', JSON.stringify(config));
            window.location.href = 'game.html';
        };

        window.saveSettings = function() {
            // Save to localStorage
            const settings = {
                quality: document.getElementById('setting-quality').value,
                volume: document.getElementById('setting-volume').value,
                scanlines: document.getElementById('setting-scanlines').checked
            };
            localStorage.setItem('stratcomSettings', JSON.stringify(settings));
            
            // Apply scanlines
            document.querySelector('.crt-overlay').style.display = 
                settings.scanlines ? 'block' : 'none';
            
            closeModal();
            logMessage('Settings saved', 'success');
        };

        function generateCodename() {
            const adj = ['THUNDER', 'IRON', 'STEEL', 'SHADOW', 'RAPID', 'SILENT', 'DESERT', 'ARCTIC'];
            const noun = ['STORM', 'SHIELD', 'SPEAR', 'EAGLE', 'LION', 'FURY', 'DAWN', 'STRIKE'];
            return adj[Math.floor(Math.random() * adj.length)] + ' ' + 
                   noun[Math.floor(Math.random() * noun.length)];
        }

        async function loadSavedGames() {
            const list = document.getElementById('saves-list');
            list.innerHTML = '<div class="saves-loading">SCANNING ARCHIVES...</div>';
            
            try {
                const user = auth.currentUser;
                if (!user) return;
                
                const saves = await db.collection('players').doc(user.uid)
                    .collection('saves').orderBy('savedAt', 'desc').limit(10).get();
                
                if (saves.empty) {
                    list.innerHTML = '<div class="saves-empty">NO SAVED CAMPAIGNS FOUND</div>';
                    return;
                }
                
                list.innerHTML = '';
                saves.forEach(doc => {
                    const data = doc.data();
                    const div = document.createElement('div');
                    div.className = 'save-item';
                    div.innerHTML = `
                        <div class="save-info">
                            <div class="save-name">${data.name || 'UNNAMED'}</div>
                            <div class="save-meta">${data.nation || 'Unknown'} ‚Ä¢ ${formatDate(data.savedAt)}</div>
                        </div>
                        <button class="save-load" onclick="loadGame('${doc.id}')">LOAD</button>
                    `;
                    list.appendChild(div);
                });
            } catch (error) {
                list.innerHTML = '<div class="saves-empty">ERROR ACCESSING ARCHIVES</div>';
                console.error(error);
            }
        }
        
        window.loadGame = async function(saveId) {
            sessionStorage.setItem('loadGameId', saveId);
            window.location.href = 'game.html';
        };

        async function loadUserStats(uid) {
            try {
                const doc = await db.collection('players').doc(uid).get();
                if (doc.exists) {
                    const data = doc.data();
                    document.getElementById('stat-campaigns').textContent = data.gamesPlayed || 0;
                    document.getElementById('stat-wins').textContent = data.stats?.wins || 0;
                    // Format playtime
                    const hours = Math.floor((data.playtime || 0) / 60);
                    const mins = (data.playtime || 0) % 60;
                    document.getElementById('stat-time').textContent = `${hours}h ${mins}m`;
                }
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString().slice(0, 5);
        }

        function updateTime() {
            const now = new Date();
            document.getElementById('system-time').textContent = 
                now.toISOString().split('T')[1].split('.')[0] + ' UTC';
        }

        // ==================== CONSOLE LOG ====================
        
        const maxConsoleLines = 50;
        
        function logMessage(message, type = 'info') {
            const console = document.getElementById('console-output');
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            
            const time = new Date().toISOString().split('T')[1].split('.')[0];
            line.innerHTML = `<span class="console-time">[${time}]</span> ${message}`;
            
            console.appendChild(line);
            
            // Limit lines
            while (console.children.length > maxConsoleLines) {
                console.removeChild(console.firstChild);
            }
            
            console.scrollTop = console.scrollHeight;
        }

        // ==================== GLOBE RENDERER ====================
        
        let scene, camera, renderer, globe, atmosphere, controls;
        let satellites = [];
        let missiles = [];
        let fleets = [];
        let scanTarget = null;
        
        function initGlobe() {
            const container = document.getElementById('globe-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.z = 4;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.3;
            controls.enableZoom = false;
            controls.enablePan = false;
            
            // Create Earth
            createEarth();
            
            // Create atmosphere
            createAtmosphere();
            
            // Create satellites
            createSatellites(15);
            
            // Create background stars
            createStars();
            
            // Create 3D scan line
            createScanLine();
            
            // Start animation
            animate();
            
            // Handle resize
            window.addEventListener('resize', onResize);
            
            // Start random events
            setInterval(launchMissile, 8000);
            setInterval(scanArea, 12000);
            
            // Initial events after a short delay
            setTimeout(scanArea, 2000);
            setTimeout(launchMissile, 4000);
            
            logMessage('Globe renderer initialized', 'success');
        }
        
        function createEarth() {
            const geometry = new THREE.SphereGeometry(1, 64, 64);
            
            // Create procedural texture
            const canvas = document.createElement('canvas');
            canvas.width = 2048;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Ocean
            ctx.fillStyle = '#0a1520';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw continents (simplified)
            ctx.fillStyle = '#1a2a20';
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            
            // Draw grid lines
            ctx.strokeStyle = '#00ff8822';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 18; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * (canvas.height / 18));
                ctx.lineTo(canvas.width, i * (canvas.height / 18));
                ctx.stroke();
            }
            for (let i = 0; i <= 36; i++) {
                ctx.beginPath();
                ctx.moveTo(i * (canvas.width / 36), 0);
                ctx.lineTo(i * (canvas.width / 36), canvas.height);
                ctx.stroke();
            }
            
            // Simplified continents
            const continents = [
                // North America
                [[200, 150], [500, 100], [600, 200], [550, 400], [350, 450], [150, 300]],
                // South America
                [[400, 500], [500, 480], [520, 700], [450, 850], [350, 800], [380, 600]],
                // Europe
                [[900, 120], [1100, 100], [1150, 200], [1100, 300], [950, 280], [880, 180]],
                // Africa
                [[900, 350], [1100, 320], [1150, 500], [1050, 700], [900, 680], [850, 500]],
                // Asia
                [[1150, 100], [1600, 80], [1700, 200], [1650, 400], [1400, 450], [1200, 350], [1100, 200]],
                // Australia
                [[1500, 600], [1650, 580], [1700, 700], [1600, 780], [1480, 750]]
            ];
            
            ctx.fillStyle = '#152520';
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            
            continents.forEach(continent => {
                ctx.beginPath();
                ctx.moveTo(continent[0][0], continent[0][1]);
                continent.forEach(point => ctx.lineTo(point[0], point[1]));
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                bumpScale: 0.02,
                specular: new THREE.Color(0x333333),
                shininess: 5
            });
            
            globe = new THREE.Mesh(geometry, material);
            scene.add(globe);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);
        }
        
        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(1.05, 64, 64);
            const material = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.65 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                        gl_FragColor = vec4(0.0, 1.0, 0.53, 1.0) * intensity * 0.5;
                    }
                `,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true
            });
            
            atmosphere = new THREE.Mesh(geometry, material);
            scene.add(atmosphere);
        }
        
        function createSatellites(count) {
            // Create different orbit types like real satellites
            const orbitTypes = [
                // Low Earth Orbit (LEO) - fast, inclined
                { minRadius: 1.15, maxRadius: 1.25, minSpeed: 0.008, maxSpeed: 0.012, inclinationRange: [0.4, 1.2] },
                // Medium Earth Orbit (MEO) - GPS-like
                { minRadius: 1.35, maxRadius: 1.45, minSpeed: 0.004, maxSpeed: 0.006, inclinationRange: [0.3, 0.9] },
                // Geostationary (GEO) - equatorial, slow
                { minRadius: 1.6, maxRadius: 1.65, minSpeed: 0.001, maxSpeed: 0.002, inclinationRange: [0, 0.1] },
                // Polar orbit - passes over poles
                { minRadius: 1.2, maxRadius: 1.3, minSpeed: 0.006, maxSpeed: 0.01, inclinationRange: [1.4, 1.57] },
                // Sun-synchronous - high inclination
                { minRadius: 1.18, maxRadius: 1.28, minSpeed: 0.007, maxSpeed: 0.009, inclinationRange: [1.5, 1.7] }
            ];
            
            for (let i = 0; i < count; i++) {
                // Pick orbit type with weighted distribution
                const orbitType = orbitTypes[Math.floor(Math.random() * orbitTypes.length)];
                
                const radius = orbitType.minRadius + Math.random() * (orbitType.maxRadius - orbitType.minRadius);
                const speed = orbitType.minSpeed + Math.random() * (orbitType.maxSpeed - orbitType.minSpeed);
                const inclination = orbitType.inclinationRange[0] + Math.random() * (orbitType.inclinationRange[1] - orbitType.inclinationRange[0]);
                const phase = Math.random() * Math.PI * 2;
                const raan = Math.random() * Math.PI * 2; // Right Ascension of Ascending Node
                
                // Create satellite body - small glowing box
                const satGroup = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.02, 0.02, 0.04);
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                satGroup.add(body);
                
                // Solar panels
                const panelGeometry = new THREE.PlaneGeometry(0.06, 0.015);
                const panelMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x4488ff, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                leftPanel.position.x = -0.04;
                leftPanel.rotation.y = Math.PI / 2;
                satGroup.add(leftPanel);
                
                const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                rightPanel.position.x = 0.04;
                rightPanel.rotation.y = Math.PI / 2;
                satGroup.add(rightPanel);
                
                // Glowing point for visibility
                const glowGeometry = new THREE.SphereGeometry(0.015, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.9
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                satGroup.add(glow);
                
                satGroup.userData = { radius, speed, inclination, raan, angle: phase, eccentricity: 0 };
                satellites.push(satGroup);
                scene.add(satGroup);
                
                // Orbit trail
                const trailGeometry = new THREE.BufferGeometry();
                const trailPoints = [];
                for (let j = 0; j <= 100; j++) {
                    const a = (j / 100) * Math.PI * 2;
                    // Proper orbital mechanics: rotate around inclination axis
                    const x = Math.cos(a) * radius;
                    const y = Math.sin(a) * radius * Math.sin(inclination);
                    const z = Math.sin(a) * radius * Math.cos(inclination);
                    // Rotate by RAAN
                    const xr = x * Math.cos(raan) - z * Math.sin(raan);
                    const zr = x * Math.sin(raan) + z * Math.cos(raan);
                    trailPoints.push(xr, y, zr);
                }
                trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPoints, 3));
                const trailMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x00ff88, 
                    transparent: true, 
                    opacity: 0.12 
                });
                const trail = new THREE.Line(trailGeometry, trailMaterial);
                scene.add(trail);
            }
        }
        
        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            for (let i = 0; i < 2000; i++) {
                const r = 50 + Math.random() * 50;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        
        // 3D Radar scan line - pole to pole
        let scanLine, scanLineAngle = 0;
        
        function createScanLine() {
            // Create a pole-to-pole arc on the globe surface
            const scanGeometry = new THREE.BufferGeometry();
            const points = [];
            
            // Create arc from north pole to south pole
            for (let i = 0; i <= 50; i++) {
                const lat = (i / 50) * Math.PI - Math.PI / 2; // -90 to +90 degrees
                const lon = 0; // Will be rotated in animation
                const r = 1.015; // Slightly above globe surface
                
                points.push(
                    r * Math.cos(lat) * Math.cos(lon),
                    r * Math.sin(lat),
                    r * Math.cos(lat) * Math.sin(lon)
                );
            }
            
            scanGeometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
            
            const scanMaterial = new THREE.LineBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.8
            });
            
            scanLine = new THREE.Line(scanGeometry, scanMaterial);
            scene.add(scanLine);
            
            // Add a trailing glow effect - multiple fading lines behind the scan
            for (let t = 1; t <= 5; t++) {
                const trailGeometry = new THREE.BufferGeometry();
                trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                const trailMaterial = new THREE.LineBasicMaterial({
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.3 - (t * 0.05)
                });
                const trailLine = new THREE.Line(trailGeometry, trailMaterial);
                trailLine.userData = { offset: t * 0.05 }; // Rotation offset
                scanLine.add(trailLine);
            }
        }
        
        function updateScanLine() {
            if (!scanLine) return;
            
            scanLineAngle += 0.005; // Rotation speed
            if (scanLineAngle > Math.PI * 2) scanLineAngle = 0;
            
            scanLine.rotation.y = scanLineAngle;
            
            // Update trailing lines
            scanLine.children.forEach(trail => {
                trail.rotation.y = -trail.userData.offset;
            });
        }
        
        function launchMissile() {
            // Random start and end points on globe
            const startLat = (Math.random() - 0.5) * Math.PI * 0.8; // Limit latitude range
            const startLon = Math.random() * Math.PI * 2;
            const endLat = (Math.random() - 0.5) * Math.PI * 0.8;
            const endLon = Math.random() * Math.PI * 2;
            
            const start = latLonToVector3(startLat, startLon, 1.02);
            const end = latLonToVector3(endLat, endLon, 1.02);
            
            // Calculate proper arc height based on distance
            const distance = start.distanceTo(end);
            const arcHeight = 1.0 + Math.max(0.3, distance * 0.4); // Higher arc for longer distances
            
            // Create arc with control point properly above the surface
            const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            mid.normalize().multiplyScalar(arcHeight); // Arc height scales with distance
            
            const curve = new THREE.QuadraticBezierCurve3(start, mid, end);
            const points = curve.getPoints(50);
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xff4444, 
                transparent: true, 
                opacity: 0.8 
            });
            
            const missile = new THREE.Line(geometry, material);
            missile.userData = { 
                progress: 0, 
                points: points,
                endPoint: end 
            };
            
            missiles.push(missile);
            scene.add(missile);
            
            // Animate missile
            animateMissile(missile);
            
            logMessage('BALLISTIC LAUNCH DETECTED - TRACKING', 'warning');
        }
        
        function animateMissile(missile) {
            const duration = 3000;
            const startTime = Date.now();
            
            function update() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Update visible portion of path
                const visiblePoints = missile.userData.points.slice(0, Math.floor(progress * 50) + 1);
                missile.geometry.setFromPoints(visiblePoints);
                
                if (progress >= 1) {
                    // Create explosion effect
                    createExplosion(missile.userData.endPoint);
                    scene.remove(missile);
                    missiles = missiles.filter(m => m !== missile);
                    logMessage('IMPACT CONFIRMED - ASSESSING DAMAGE', 'error');
                } else {
                    requestAnimationFrame(update);
                }
            }
            update();
        }
        
        function createExplosion(position) {
            const geometry = new THREE.SphereGeometry(0.02, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff8800, 
                transparent: true 
            });
            
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.copy(position);
            scene.add(explosion);
            
            // Animate explosion
            const startTime = Date.now();
            function animate() {
                const elapsed = Date.now() - startTime;
                const scale = 1 + elapsed / 200;
                const opacity = 1 - elapsed / 1000;
                
                explosion.scale.set(scale, scale, scale);
                explosion.material.opacity = Math.max(0, opacity);
                
                if (opacity > 0) {
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(explosion);
                }
            }
            animate();
        }
        
        // Helper to project 3D world position to 2D screen coordinates
        function worldToScreen(position) {
            const vector = position.clone();
            vector.project(camera);
            
            const container = document.getElementById('globe-container');
            const rect = container.getBoundingClientRect();
            
            return {
                x: (vector.x * 0.5 + 0.5) * rect.width,
                y: (-vector.y * 0.5 + 0.5) * rect.height
            };
        }
        
        function scanArea() {
            const tracker = document.getElementById('scan-tracker');
            const scanClass = document.getElementById('scan-class');
            const scanId = document.getElementById('scan-id');
            const scanType = document.getElementById('scan-type');
            const scanDetails = document.getElementById('scan-details');
            const scanStatus = document.getElementById('scan-status');
            
            // Generate target ID
            const targetId = 'TGT-' + String(Math.floor(Math.random() * 9999)).padStart(4, '0');
            
            // Intelligence reports
            const intelReports = [
                // Naval
                { type: 'CARRIER STRIKE GROUP', classification: 'hostile', 
                  details: [
                    { label: 'COMPOSITION', value: `${Math.floor(Math.random()*2+1)} CVN, ${Math.floor(Math.random()*4+2)} DDG` },
                    { label: 'HEADING', value: `${Math.floor(Math.random()*360)}¬∞ at ${Math.floor(Math.random()*20+10)} KTS` },
                    { label: 'AIR OPS', value: Math.random() > 0.5 ? 'ACTIVE' : 'STANDBY' }
                  ], status: 'alert', statusText: '‚ö† HIGH PRIORITY TARGET' },
                { type: 'SUBMARINE CONTACT', classification: 'hostile',
                  details: [
                    { label: 'CLASS', value: ['AKULA', 'OSCAR II', 'YASEN', 'BOREI'][Math.floor(Math.random()*4)] },
                    { label: 'DEPTH', value: `${Math.floor(Math.random()*300+50)}M` },
                    { label: 'CONFIDENCE', value: `${Math.floor(Math.random()*30+70)}%` }
                  ], status: 'tracking', statusText: 'TRACKING - SONAR CONTACT' },
                { type: 'MERCHANT CONVOY', classification: 'neutral',
                  details: [
                    { label: 'VESSELS', value: `${Math.floor(Math.random()*12+3)} SHIPS` },
                    { label: 'CARGO', value: ['CONTAINERS', 'BULK', 'TANKER', 'MIXED'][Math.floor(Math.random()*4)] },
                    { label: 'FLAG', value: ['PANAMA', 'LIBERIA', 'MARSHALL IS.'][Math.floor(Math.random()*3)] }
                  ], status: 'monitoring', statusText: 'MONITORING - NO THREAT' },
                // Air
                { type: 'FIGHTER FORMATION', classification: 'hostile',
                  details: [
                    { label: 'AIRCRAFT', value: `${Math.floor(Math.random()*8+4)}x ${['SU-35', 'J-20', 'MIG-31'][Math.floor(Math.random()*3)]}` },
                    { label: 'ALTITUDE', value: `FL${Math.floor(Math.random()*200+250)}` },
                    { label: 'SPEED', value: `MACH ${(Math.random()*0.5+0.8).toFixed(1)}` }
                  ], status: 'alert', statusText: '‚ö† INTERCEPT ADVISORY' },
                { type: 'DRONE SWARM', classification: 'hostile',
                  details: [
                    { label: 'COUNT', value: `${Math.floor(Math.random()*50+20)} UNITS` },
                    { label: 'FORMATION', value: ['DISPERSED', 'TIGHT', 'ECHELON'][Math.floor(Math.random()*3)] },
                    { label: 'JAMMING', value: Math.random() > 0.5 ? 'DETECTED' : 'NONE' }
                  ], status: 'alert', statusText: '‚ö† ELECTRONIC WARFARE ALERT' },
                // Ground
                { type: 'MILITARY BUILDUP', classification: 'hostile',
                  details: [
                    { label: 'FORCES', value: `~${Math.floor(Math.random()*50+10)}K PERSONNEL` },
                    { label: 'ARMOR', value: `${Math.floor(Math.random()*200+50)} MBT` },
                    { label: 'ACTIVITY', value: ['STAGING', 'EXERCISES', 'MOBILIZING'][Math.floor(Math.random()*3)] }
                  ], status: 'alert', statusText: '‚ö† SIGINT PRIORITY' },
                { type: 'LAUNCH FACILITY', classification: 'hostile',
                  details: [
                    { label: 'TYPE', value: ['ICBM', 'IRBM', 'SAM'][Math.floor(Math.random()*3)] + ' COMPLEX' },
                    { label: 'STATUS', value: ['ELEVATED', 'NORMAL', 'ACTIVE'][Math.floor(Math.random()*3)] },
                    { label: 'LAST UPDATE', value: `${Math.floor(Math.random()*24)}H AGO` }
                  ], status: 'tracking', statusText: 'CONTINUOUS SURVEILLANCE' },
                // Friendly
                { type: 'ALLIED PATROL', classification: 'friendly',
                  details: [
                    { label: 'CALLSIGN', value: ['EAGLE', 'VIPER', 'SHADOW'][Math.floor(Math.random()*3)] + '-' + Math.floor(Math.random()*9+1) },
                    { label: 'MISSION', value: ['PATROL', 'ESCORT', 'RECON'][Math.floor(Math.random()*3)] },
                    { label: 'FUEL', value: `${Math.floor(Math.random()*40+60)}%` }
                  ], status: 'monitoring', statusText: 'FRIENDLY - IFF CONFIRMED' },
                { type: 'RECON SATELLITE', classification: 'friendly',
                  details: [
                    { label: 'ASSET', value: 'KH-' + Math.floor(Math.random()*5+11) },
                    { label: 'PASS', value: `T+${Math.floor(Math.random()*60)}MIN` },
                    { label: 'COVERAGE', value: `${Math.floor(Math.random()*500+200)}KM SWATH` }
                  ], status: 'monitoring', statusText: 'TASKED - IMAGERY PENDING' }
            ];
            
            const intel = intelReports[Math.floor(Math.random() * intelReports.length)];
            
            // Generate 3D path points on globe surface (visible front face)
            const targetLat = (Math.random() - 0.5) * Math.PI * 0.6; // Limit latitude
            const targetLon = (Math.random() - 0.5) * Math.PI * 0.8; // Visible hemisphere
            const targetPos = latLonToVector3(targetLat, targetLon, 1.02);
            
            // Create search path with 3 waypoints before target
            const searchPath = [];
            for (let i = 0; i < 3; i++) {
                const lat = (Math.random() - 0.5) * Math.PI * 0.5;
                const lon = (Math.random() - 0.5) * Math.PI * 0.6;
                searchPath.push(latLonToVector3(lat, lon, 1.02));
            }
            searchPath.push(targetPos);
            
            // Start animation
            let currentWaypoint = 0;
            tracker.classList.remove('locked', 'zooming');
            tracker.classList.add('active');
            
            logMessage(`INITIATING SCAN - SECTOR ${String.fromCharCode(65 + Math.floor(Math.random()*8))}${Math.floor(Math.random()*9+1)}`, 'info');
            
            function animateToWaypoint() {
                if (currentWaypoint >= searchPath.length) {
                    // Reached target - lock on
                    setTimeout(() => {
                        tracker.classList.add('locked');
                        
                        // Update info panel
                        scanId.textContent = targetId;
                        scanClass.textContent = intel.classification.toUpperCase();
                        scanClass.className = 'scan-classification ' + intel.classification;
                        scanType.textContent = intel.type;
                        
                        scanDetails.innerHTML = intel.details.map(d => 
                            `<div class="scan-detail-row">
                                <span class="scan-detail-label">${d.label}:</span>
                                <span class="scan-detail-value">${d.value}</span>
                            </div>`
                        ).join('');
                        
                        scanStatus.textContent = intel.statusText;
                        scanStatus.className = 'scan-status ' + intel.status;
                        
                        logMessage(`TARGET ACQUIRED: ${intel.type} - ${intel.classification.toUpperCase()}`, 
                            intel.classification === 'hostile' ? 'warning' : 'info');
                        
                        // Hold for display then hide
                        setTimeout(() => {
                            tracker.classList.remove('locked', 'active');
                        }, 5000);
                        
                    }, 300);
                    return;
                }
                
                const targetPos3D = searchPath[currentWaypoint];
                const duration = 600; // Animation duration per waypoint
                const startTime = Date.now();
                const startPos = tracker.style.left ? 
                    { x: parseFloat(tracker.style.left), y: parseFloat(tracker.style.top) } :
                    worldToScreen(searchPath[0]);
                
                function updatePosition() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                    
                    const targetScreen = worldToScreen(targetPos3D);
                    const x = startPos.x + (targetScreen.x - startPos.x) * eased;
                    const y = startPos.y + (targetScreen.y - startPos.y) * eased;
                    
                    tracker.style.left = x + 'px';
                    tracker.style.top = y + 'px';
                    
                    if (progress < 1) {
                        requestAnimationFrame(updatePosition);
                    } else {
                        currentWaypoint++;
                        setTimeout(animateToWaypoint, 200);
                    }
                }
                
                updatePosition();
            }
            
            // Initialize position and start
            const initialScreen = worldToScreen(searchPath[0]);
            tracker.style.left = initialScreen.x + 'px';
            tracker.style.top = initialScreen.y + 'px';
            setTimeout(animateToWaypoint, 100);
        }
        
        function latLonToVector3(lat, lon, radius) {
            return new THREE.Vector3(
                radius * Math.cos(lat) * Math.cos(lon),
                radius * Math.sin(lat),
                radius * Math.cos(lat) * Math.sin(lon)
            );
        }
        
        function onResize() {
            const container = document.getElementById('globe-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update satellites with proper orbital mechanics
            satellites.forEach(sat => {
                sat.userData.angle += sat.userData.speed;
                const a = sat.userData.angle;
                const r = sat.userData.radius;
                const inc = sat.userData.inclination;
                const raan = sat.userData.raan; // Right Ascension of Ascending Node
                const ecc = sat.userData.eccentricity || 0;
                
                // Kepler's equation for elliptical orbits
                const actualRadius = r * (1 - ecc * ecc) / (1 + ecc * Math.cos(a));
                
                // Position in orbital plane
                const xOrbit = actualRadius * Math.cos(a);
                const yOrbit = actualRadius * Math.sin(a);
                
                // Transform to 3D space using orbital elements
                const cosInc = Math.cos(inc);
                const sinInc = Math.sin(inc);
                const cosRaan = Math.cos(raan);
                const sinRaan = Math.sin(raan);
                
                // Apply rotation matrices for proper orbital orientation
                sat.position.set(
                    xOrbit * cosRaan - yOrbit * cosInc * sinRaan,
                    yOrbit * sinInc,
                    xOrbit * sinRaan + yOrbit * cosInc * cosRaan
                );
                
                // Update trail
                if (sat.userData.trail) {
                    sat.userData.trailPositions.push(sat.position.clone());
                    if (sat.userData.trailPositions.length > sat.userData.trailLength) {
                        sat.userData.trailPositions.shift();
                    }
                    sat.userData.trail.geometry.setFromPoints(sat.userData.trailPositions);
                }
                
                // Rotate solar panels to face the sun (simulated at fixed direction)
                if (sat.children.length > 0) {
                    sat.children.forEach(panel => {
                        panel.lookAt(10, 5, 0); // Sun direction
                    });
                }
            });
            
            // Update the pole-to-pole scan line
            updateScanLine();
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Update tracked objects count periodically
        setInterval(() => {
            const count = 2800 + Math.floor(Math.random() * 100);
            document.getElementById('tracked-objects').textContent = count.toLocaleString();
        }, 5000);
    </script>
</body>
</html>
